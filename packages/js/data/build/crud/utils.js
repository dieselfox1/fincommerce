"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getGenericActionName = exports.getRequestIdentifier = exports.cleanQuery = exports.maybeReplaceIdQuery = exports.isValidIdQuery = exports.getUrlParameters = exports.getNamespaceKeys = exports.applyNamespace = exports.parseId = exports.organizeItemsById = exports.getKey = exports.getRestPath = void 0;
exports.filterDataByKeys = filterDataByKeys;
/**
 * External dependencies
 */
const url_1 = require("@wordpress/url");
/**
 * Internal dependencies
 */
const crud_actions_1 = __importDefault(require("./crud-actions"));
const utils_1 = require("../utils");
/**
 * Get a REST path given a template path and URL params.
 *
 * @param templatePath Path with variable names.
 * @param query        Item query.
 * @param parameters   Array of items to replace in the templatePath.
 * @return string REST path.
 */
const getRestPath = (templatePath, query, parameters) => {
    let path = templatePath;
    path.match(/{(.*?)}/g)?.forEach((str, i) => {
        path = path.replace(str, parameters[i].toString());
    });
    const regex = new RegExp(/{|}/);
    if (regex.test(path.toString())) {
        throw new Error('Not all URL parameters were replaced');
    }
    return (0, url_1.addQueryArgs)(path, query);
};
exports.getRestPath = getRestPath;
/**
 * Get a key from an item ID and optional parent.
 *
 * @param query         Item Query.
 * @param urlParameters Parameters used for URL.
 * @return string
 */
const getKey = (query, urlParameters = []) => {
    const id = typeof query === 'string' || typeof query === 'number'
        ? query
        : query.id;
    if (!urlParameters.length) {
        return id;
    }
    return urlParameters.join('/') + '/' + id;
};
exports.getKey = getKey;
/**
 * This function takes an array of items and reduces it into a single object,
 * where each key is a unique identifier generated by
 * combining the item ID and optional URL parameters.
 * It also returns an array of these keys (`ids`).
 *
 * @param {Array<Item>}          items         - The items to process.
 * @param {Array<IdType>}        urlParameters - The URL parameters used to generate keys.
 * @param {Record<string, Item>} currentState  - The current state data to merge with.
 * @return {organizeItemsByIdReturn} An object with two properties: `objItems` and `ids`.
 */
const organizeItemsById = (items, urlParameters = [], currentState = {}) => {
    const ids = [];
    const objItems = {};
    const hasUrlParams = urlParameters.length > 0;
    items.forEach((item) => {
        const key = hasUrlParams ? (0, exports.getKey)(item.id, urlParameters) : item.id;
        ids.push(key);
        objItems[key] = {
            ...(currentState[key] || {}),
            ...item,
        };
    });
    return { objItems, ids };
};
exports.organizeItemsById = organizeItemsById;
/**
 * Filters the input data object, returning a new object that contains only the keys
 * specified in the keys array.
 *
 * @param {Record<string, unknown>} data - The original data object to filter.
 * @param {IdType[]}                keys - An array of keys that should be included in the returned object.
 * @return {Record<string, unknown>} A new object containing only the specified keys.
 */
function filterDataByKeys(data, keys) {
    return keys.reduce((acc, key) => {
        if (data[key]) {
            acc[key] = data[key];
        }
        return acc;
    }, {});
}
/**
 * Parse an ID query into a ID string.
 *
 * @param query Id Query
 * @return string ID.
 */
const parseId = (query, urlParameters = []) => {
    if (typeof query === 'string' || typeof query === 'number') {
        return {
            id: query,
            key: query,
        };
    }
    return {
        id: query.id,
        key: (0, exports.getKey)(query, urlParameters),
    };
};
exports.parseId = parseId;
/**
 * Create a new function that adds in the namespace.
 *
 * @param fn        Function to wrap.
 * @param namespace Namespace to pass to last argument of function.
 * @return Wrapped function
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const applyNamespace = (fn, namespace, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
defaultArgs = []) => {
    return (...args) => {
        defaultArgs.forEach((defaultArg, index) => {
            // skip first item, as that is the state.
            if (args[index + 1] === undefined) {
                args[index + 1] = defaultArg;
            }
        });
        return fn(...args, namespace);
    };
};
exports.applyNamespace = applyNamespace;
/**
 * Get the key names from a namespace string.
 *
 * @param namespace Namespace to get keys from.
 * @return Array of keys.
 */
const getNamespaceKeys = (namespace) => {
    const keys = [];
    namespace.match(/{(.*?)}/g)?.forEach((match) => {
        const key = match.substr(1, match.length - 2);
        keys.push(key);
    });
    return keys;
};
exports.getNamespaceKeys = getNamespaceKeys;
/**
 * Get URL parameters from namespace and provided query.
 *
 * @param namespace Namespace string to replace params in.
 * @param query     Query object with key values.
 * @return Array of URL parameter values.
 */
const getUrlParameters = (namespace, query) => {
    if (typeof query !== 'object') {
        return [];
    }
    const params = [];
    const keys = (0, exports.getNamespaceKeys)(namespace);
    keys.forEach((key) => {
        if (query.hasOwnProperty(key)) {
            params.push(query[key]);
        }
    });
    return params;
};
exports.getUrlParameters = getUrlParameters;
/**
 * Check to see if an argument is a valid type of ID query.
 *
 * @param arg       Unknow argument to check.
 * @param namespace The namespace string
 * @return boolean
 */
const isValidIdQuery = (arg, namespace) => {
    if (typeof arg === 'string' || typeof arg === 'number') {
        return true;
    }
    const validKeys = ['id', ...(0, exports.getNamespaceKeys)(namespace)];
    if (arg &&
        typeof arg === 'object' &&
        arg.hasOwnProperty('id') &&
        JSON.stringify(validKeys.sort()) ===
            JSON.stringify(Object.keys(arg).sort())) {
        return true;
    }
    return false;
};
exports.isValidIdQuery = isValidIdQuery;
/**
 * Replace the initial argument with a key if it's a valid ID query.
 *
 * @param args      Args to check.
 * @param namespace Namespace.
 * @return Sanitized arguments.
 */
const maybeReplaceIdQuery = (args, namespace) => {
    const [firstArgument, ...rest] = args;
    if (!firstArgument || !(0, exports.isValidIdQuery)(firstArgument, namespace)) {
        return args;
    }
    const urlParameters = (0, exports.getUrlParameters)(namespace, firstArgument);
    const { key } = (0, exports.parseId)(firstArgument, urlParameters);
    return [key, ...rest];
};
exports.maybeReplaceIdQuery = maybeReplaceIdQuery;
/**
 * Clean a query of all namespaced params.
 *
 * @param query     Query to clean.
 * @param namespace
 * @return Cleaned query object.
 */
const cleanQuery = (query, namespace) => {
    const cleaned = { ...query };
    const keys = (0, exports.getNamespaceKeys)(namespace);
    keys.forEach((key) => {
        delete cleaned[key];
    });
    return cleaned;
};
exports.cleanQuery = cleanQuery;
/**
 * Get the identifier for a request provided its arguments.
 *
 * @param name Name of action or selector.
 * @param args Arguments for the request.
 * @return Key to identify the request.
 */
exports.getRequestIdentifier = utils_1.getResourceName;
/**
 * Get a generic action name from a resource action name if one exists.
 *
 * @param action       Action name to check.
 * @param resourceName Resource name.
 * @return Generic action name if one exists, otherwise the passed action name.
 */
const getGenericActionName = (action, resourceName) => {
    switch (action) {
        case `create${resourceName}`:
            return crud_actions_1.default.CREATE_ITEM;
        case `delete${resourceName}`:
            return crud_actions_1.default.DELETE_ITEM;
        case `update${resourceName}`:
            return crud_actions_1.default.UPDATE_ITEM;
    }
    return action;
};
exports.getGenericActionName = getGenericActionName;
